#include <QTRSensors.h>
#include <AStar32U4Motors.h>
#include <Encoder.h>
AStar32U4Motors m; //motor assignment
QTRSensors qtr;
const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];
uint16_t linePosition;

const byte numChars = 32;
char receivedChars[numChars];
char tempChar[numChars]; // temporary array used for parsing

//motor command variables
int leftMotor=0; //int leftMotor
int rightMotor=0;
int isCross=0;

//PID parameters
float Kp = 0.0;
float Ki = 0.0;
float Kd = 0.0;

uint8_t multiP = 1;
uint8_t multiI = 1;
uint8_t multiD = 1;
uint8_t Kpfinal;
uint8_t Kifinal;
uint8_t Kdfinal;
float Pvalue;
float Ivalue;
float Dvalue;

int lfspeed = 200;

int P, D, I, previousError, PIDvalue, error;
int lsp, rsp;

// --- Function declarations ---
void robot_control();
void PID_Linefollow(int error);
void commandMotors(int left, int right);
void calibrateSensors();

boolean newData = false;

void setup() {
    Serial.println("Arduino is Ready");
    Serial.begin(115200);
    m.setM1Speed(0);
    m.setM2Speed(0);
    //Connecting to line follower sensor
    qtr.setTypeRC(); //this allows us to read the line sensor from didgital pins
    //arduino pin sensornames I am using: 7, 18, A5, 20, 21, 22, 8, 6.
    qtr.setSensorPins((const uint8_t[]){7, 18, 23, 20, 21, 22, 8, 6}, SensorCount);

    calibrateSensors();
    qtr.setEmitterPin(4); //can get away with a single emitter pin providing power to both emitters
    QTRReadMode::On; //emitters on measures active reflectance instead of ambient light levels, better becasue the ambient light level will change as the robot moves around the board but the reflectance levels will not
    Serial.println("<Arduino is ready>");
}

//====================================================

void loop() {
//////REPAIRING THE READLINEBLACK FUNCTION /////////////////////////////////////
linePosition = qtr.readLineBlack(sensorValues);
//----------------------------Debug---------------------

  Serial.print(linePosition);
  Serial.print("\t");
 for (int i = 0; i < SensorCount; i++) {
   Serial.print(sensorValues[i]);
   Serial.print("\t");
 }
 Serial.println();
 delay(1000);

//------------------------------------------------------

}
//////////////////////////////////////////////////////////////////////////////////////////////////////////END OF REPAIRS TO LINEPOSITION///////////////////////////////////////////////////////////////////////////

void robot_control() {
  uint16_t position = qtr.readLineBlack(sensorValues);
  int error = 2000 - position;

  // Intersection detection: all sensors over threshold
  bool intersection = true;
  for(uint8_t i=0;i<SensorCount;i++){
    if(sensorValues[0] && sensorValues[7] < 2000){
      intersection = false;
      break;
    }
  }

  PID_Linefollow(error);
}

//////////////////////////////////////////////////////////////////////

void PID_Linefollow(int error){
  P = error;
  I += error;
  D = error - previousError;

  Pvalue = (Kp/pow(10,multiP))*P;
  Ivalue = (Ki/pow(10,multiI))*I;
  Dvalue = (Kd/pow(10,multiD))*D;

  float PIDvalue = Pvalue + Ivalue + Dvalue;
  previousError = error;

  int lsp = lfspeed - PIDvalue;
  int rsp = lfspeed + PIDvalue;

  if (lsp > 255) {
    lsp = 255;
  }
  if (lsp < -255) {
    lsp = -255;
  }
  if (rsp > 255) {
    rsp = 255;
  }
  if (rsp < -255) {
    rsp = -255;
  }
  commandMotors(lsp,rsp);
}

//////////////////////////////////////////////////////////

void commandMotors(int left, int right){
  if(left>=0){m.setM1Speed(leftMotor);
  }
  if(right>=0){m.setM2Speed(rightMotor);
  }
}


//==================================================================

void calibrateSensors(){
  //THE SENSORS ONLY CALIBRATE WHEN YOU UPLOAD NEW ARDUINO CODE TO THE ASTAR. after that the sensors STAY calibrated as long as the Astar has power.

  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH); // turn on Arduino's LED to indicate we are in calibration mode
                                   ///while calibrating, move the sensor over the line a couple times

  // 2.5 ms RC read timeout (default) * 10 reads per calibrate() call
  // = ~25 ms per calibrate() call.
  // Call calibrate() 400 times to make calibration take about 10s seconds.
  for (uint16_t i = 0; i < 400; i++)
  {
    qtr.calibrate();
  }
  digitalWrite(LED_BUILTIN, LOW); // turn off Arduino's LED to indicate we are through with calibration

}






// // put function declarations here:
// int myFunction(int, int);

// void setup() {
//   // put your setup code here, to run once:
//   int result = myFunction(2, 3);
// }

// void loop() {
//   // put your main code here, to run repeatedly:
// }

// // put function definitions here:
// int myFunction(int x, int y) {
//   return x + y;
// }
